#nullable enable
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Text;
using System.Linq;
using System.Collections.Generic;
using Microsoft.CodeAnalysis.CSharp;

namespace Elffy.Generator
{
    internal static class GeneratorUtil
    {
        public static string GetGeneratorSigniture(Type generatorType)
        {
            return
@$"// <auto-generated>
// Auto generated by a source generator.
// Generator: {generatorType.FullName} (Assembly: {generatorType.Assembly.FullName})
// </auto-generated>

";
        }

        public static StructDeclarationSyntax GetAttrTargetStructSyntax(AttributeSyntax attr)
        {
            var parent = attr.Parent;
            while(true) {
                if(parent == null) {
                    throw new Exception();
                }
                if(parent.IsKind(SyntaxKind.StructDeclaration) && parent is StructDeclarationSyntax ret) {
                    return ret;
                }
                parent = parent.Parent;
            }
        }

        public static (string structNamespace, string structName) GetAttrTargetStructName(AttributeSyntax attr, SemanticModel attrSemantic)
        {
            var s = GetAttrTargetStructSyntax(attr);
            var structDeclaration = attrSemantic.GetDeclaredSymbol(s) ?? throw new Exception();
            var structNamespace = structDeclaration.ContainingNamespace.ToString();
            var structName = structDeclaration.Name;
            return (structNamespace, structName);
        }

        public static string GetAttrArgTypeFullName(AttributeSyntax attr, int argNum, Compilation compilation)
        {
            return GetAttrArgTypeFullName(attr, argNum, compilation.GetSemanticModel(attr.SyntaxTree));
        }

        public static string GetAttrArgTypeFullName(AttributeSyntax attr, int argNum, SemanticModel semanticModel)
        {
            var expr = (TypeOfExpressionSyntax)attr.ArgumentList!.Arguments[argNum].Expression;
            return semanticModel.GetSymbolInfo(expr.Type).Symbol!.ToString();      // fullname
        }

        public static string GetAttrArgString(AttributeSyntax attr, int argNum, Compilation compilation)
        {
            return GetAttrArgString(attr, argNum, compilation.GetSemanticModel(attr.SyntaxTree));
        }

        public static string GetAttrArgString(AttributeSyntax attr, int argNum, SemanticModel semanticModel)
        {
            return semanticModel.GetConstantValue(attr.ArgumentList!.Arguments[argNum].Expression).Value!.ToString();
        }

        public static T GetAttrArgEnum<T>(AttributeSyntax attr, int argNum, Compilation compilation) where T : struct, Enum
        {
            return GetAttrArgEnum<T>(attr, argNum, compilation.GetSemanticModel(attr.SyntaxTree));
        }

        public static T GetAttrArgEnum<T>(AttributeSyntax attr, int argNum, SemanticModel semanticModel) where T : struct, Enum
        {
            return (T)semanticModel.GetConstantValue(attr.ArgumentList!.Arguments[argNum].Expression).Value!;
        }

        public static int GetAttrArgInt(AttributeSyntax attr, int argNum, Compilation compilation)
        {
            return GetAttrArgInt(attr, argNum, compilation.GetSemanticModel(attr.SyntaxTree));
        }

        public static int GetAttrArgInt(AttributeSyntax attr, int argNum, SemanticModel semanticModel)
        {
            return int.Parse(semanticModel.GetConstantValue(attr.ArgumentList!.Arguments[argNum].Expression).Value!.ToString());
        }

        public static uint GetAttrArgUInt(AttributeSyntax attr, int argNum, Compilation compilation)
        {
            return GetAttrArgUInt(attr, argNum, compilation.GetSemanticModel(attr.SyntaxTree));
        }

        public static uint GetAttrArgUInt(AttributeSyntax attr, int argNum, SemanticModel semanticModel)
        {
            return uint.Parse(semanticModel.GetConstantValue(attr.ArgumentList!.Arguments[argNum].Expression).Value!.ToString());
        }

        public static byte GetAttrArgByte(AttributeSyntax attr, int argNum, Compilation compilation)
        {
            return GetAttrArgByte(attr, argNum, compilation.GetSemanticModel(attr.SyntaxTree));
        }

        public static byte GetAttrArgByte(AttributeSyntax attr, int argNum, SemanticModel semanticModel)
        {
            return byte.Parse(semanticModel.GetConstantValue(attr.ArgumentList!.Arguments[argNum].Expression).Value!.ToString());
        }

        public static bool GetAttrArgBool(AttributeSyntax attr, int argNum, Compilation compilation)
        {
            return GetAttrArgBool(attr, argNum, compilation.GetSemanticModel(attr.SyntaxTree));
        }

        public static bool GetAttrArgBool(AttributeSyntax attr, int argNum, SemanticModel semanticModel)
        {
            return (bool)semanticModel.GetConstantValue(attr.ArgumentList!.Arguments[argNum].Expression).Value!;
        }

        public static string GetAttrArgEnumNum(AttributeSyntax attr, int argNum, Compilation compilation)
        {
            return GetAttrArgEnumNum(attr, argNum, compilation.GetSemanticModel(attr.SyntaxTree));
        }

        public static string GetAttrArgEnumNum(AttributeSyntax attr, int argNum, SemanticModel semanticModel)
        {
            return semanticModel.GetConstantValue(attr.ArgumentList!.Arguments[argNum].Expression).Value!.ToString();
        }

        public static bool IsAwaitableMethod(MethodDeclarationSyntax method, Compilation compilation)
        {
            var methodGetAwaiter = compilation.GetSemanticModel(method.ReturnType.SyntaxTree)
                                     .GetTypeInfo(method.ReturnType)
                                     .Type!
                                     .GetMembers()
                                     .OfType<IMethodSymbol>()
                                     .FirstOrDefault(m => m.Name == "GetAwaiter" && m.Parameters.IsEmpty);

            if(methodGetAwaiter is null) {
                return false;
            }

            var required = (get_IsCompleted: false, OnCompleted: false, GetResult: false);

            foreach(var member in methodGetAwaiter.ReturnType.GetMembers()) {
                switch(member.Name) {
                    case "get_IsCompleted": {
                        if(member is IMethodSymbol prop && prop.ReturnType.SpecialType == SpecialType.System_Boolean) {
                            required.get_IsCompleted = true;
                        }
                        break;
                    }
                    case "OnCompleted": {
                        if(member is IMethodSymbol m && m.ReturnsVoid && m.Parameters.Length == 1 && m.Parameters[0].Type.ToString() == "System.Action") {
                            required.OnCompleted = true;
                        }
                        break;
                    }
                    case "GetResult": {
                        if(member is IMethodSymbol m && m.Parameters.Length == 0) {
                            required.GetResult = true;
                        }
                        break;
                    }
                    default:
                        break;
                }
            }

            return required.get_IsCompleted && required.OnCompleted && required.GetResult;
        }
    }

    internal static class StringBuilderExtension
    {
        public static StringBuilder AppendIf(this StringBuilder sb, bool condition, string value)
        {
            return condition ? sb.Append(value) : sb;
        }

        public static StringBuilder AppendChoose(this StringBuilder sb, bool condition, string trueValue, string falseValue)
        {
            return condition ? sb.Append(trueValue) : sb.Append(falseValue);
        }

        public static StringBuilder AppendForeach<T>(this StringBuilder sb, IEnumerable<T> list, Func<T, string> func)
        {
            foreach(var item in list) {
                sb.Append(func(item));
            }
            return sb;
        }

        public static StringBuilder AppendForeach<T>(this StringBuilder sb, IEnumerable<T> list, Func<T, string> func, string separator)
        {
            using var e = list.GetEnumerator();
            if(e.MoveNext() == false) { return sb; }
            while(true) {
                sb.Append(func(e.Current));
                if(e.MoveNext() == false) { break; }
                sb.Append(separator);
            }
            return sb;
        }
    }
}
