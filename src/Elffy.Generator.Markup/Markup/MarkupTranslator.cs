#nullable enable
using Elffy.Generator;
using Microsoft.CodeAnalysis.Text;
using System.Diagnostics.CodeAnalysis;
using System.Text;
using System.Threading;
using U8Xml;

namespace Elffy.Markup;

public static class MarkupTranslator
{
    private const int SkippedMethodID = -1;

    public static void Translate(
        XmlObject xml,
        TypeDataStore typeStore,
        MarkupTranslationResult resultHolder,
        CancellationToken ct)
    {
        ct.ThrowIfCancellationRequested();

        if(TryGetBuilderName(xml, out var builderNS, out var builderName) == false) {
            resultHolder.AddDiagnostic(DiagnosticHelper.BuilderNotSpecified());
            return;
        }
        var sourceBuilder = new SourceStringBuilder(builderNS, builderName);
        var context = new MarkupTranslatorContext(xml, sourceBuilder, typeStore, resultHolder, ct);
        sourceBuilder.Header.AppendLine(@"// <auto-generated>
// Auto generated by a source generator.
// Generator: Elffy.Generator.MarkupTranslationGenerator
// </auto-generated>

#nullable enable");

        var rootNode = xml.Root;
        var rootMethod = sourceBuilder.CreateMethodBuilder(2, out _);
        var (id, returnedType) = GenerateFactoryMethodCode(rootNode, null, context);

        if(id == SkippedMethodID || returnedType == null) {
            rootMethod.AppendLine("[global::System.Obsolete(\"The markup file was not translated to code successfully.\", true)]");
            if(returnedType == null) {
                rootMethod.AppendLine($"public static async global::Cysharp.Threading.Tasks.UniTask Create()");
            }
            else {
                rootMethod.AppendLine($"public static async global::Cysharp.Threading.Tasks.UniTask<global::{returnedType.Name}> Create()");
            }
            rootMethod.AppendLine("{ throw new global::System.InvalidOperationException(\"The markup file was not translated to code successfully.\"); }");
            return;
        }

        var unitaskT = $"global::Cysharp.Threading.Tasks.UniTask<global::{returnedType.Name}>";
        rootMethod.AppendLine($@"public static async {unitaskT} Create(global::System.Func<global::{returnedType.Name}, {unitaskT}>? beforeInit = null)");
        rootMethod.AppendLine("{");
        rootMethod.IncrementIndent();
        rootMethod.AppendLine("var context = new Context();");
        rootMethod.AppendLine("try {");
        rootMethod.AppendLine($"    var obj = __F{id}(ref context);");
        rootMethod.AppendLine("    await (beforeInit?.Invoke(obj) ?? default);");
        rootMethod.AppendLine("    await context.WhenAllTask();");
        rootMethod.AppendLine("    return obj;");
        rootMethod.AppendLine("} finally { context.Dispose(); }");
        rootMethod.DecrementIndent();
        rootMethod.AppendLine("}");

        var source = sourceBuilder.ToString();
        var result = SourceText.From(source, Encoding.UTF8);
        resultHolder.SetResult(result);

    }

    private static bool TryGetBuilderName(XmlObject xml, [MaybeNullWhen(false)] out string builderNS, [MaybeNullWhen(false)] out string builderName)
    {
        // x:builder="Foo.Bar.Baz" xmlns:x="Elffy.Markup.Extensions"

        // TODO:
        if(xml.Root.TryFindAttribute("Elffy.Markup.Extensions", "builder", out var attr) == false) {
            builderNS = null;
            builderName = null;
            return false;
        }
        var value = attr.Value;
        int i;
        for(i = value.Length - 1; i >= 0; i--) {
            if(value[i] == (byte)'.') {
                break;
            }
        }
        builderNS = value.Slice(0, i).ToString();
        builderName = value.Slice(i + 1).ToString();
        return true;
    }

    private static (int MethodID, TypeData? ReturnedType) GenerateFactoryMethodCode(XmlNode node, TypeData? callerObjType, MarkupTranslatorContext context)
    {
        context.CancellationToken.ThrowIfCancellationRequested();

        var typeStore = context.TypeStore;
        var nodeTypeName = node.GetTypeFullName().ToString();
        if(typeStore.TryGetTypeData(nodeTypeName, out var instanceType) == false) {
            context.AddDiagnostic(DiagnosticHelper.TypeNotFound(nodeTypeName));
            return (SkippedMethodID, null);
        }

        var mb = context.SourceBuilder.CreateMethodBuilder(2, out var methodId);
        if(callerObjType == null) {
            mb.AppendLine($"private static global::{instanceType.Name} __F{methodId}(ref Context context)");
        }
        else {
            mb.AppendLine($"private static global::{instanceType.Name} __F{methodId}(ref Context context, in global::{callerObjType.Name} caller)");
        }
        mb.AppendLine("{");
        mb.IncrementIndent();
        if(node.InnerText.IsEmpty) {
            mb.AppendLine($"var obj = new global::{instanceType.Name}();");
        }
        else {
            // typed literal
            var literal = node.InnerText.ToString();
            if(instanceType.TryGetLiteralCode(literal, out var literalCode, out var diagnostic)) {
                mb.AppendLine($"var obj = {literalCode};");
            }
            else {
                context.AddDiagnostic(diagnostic);
                if(instanceType.IsValueType) {
                    mb.AppendLine($"var obj = default(global::{instanceType.Name});");
                }
                else {
                    mb.AppendLine($"var obj = default(global::{instanceType.Name})!;");
                }
            }
        }

        foreach(var attr in node.Attributes) {
            if(attr.IsNamespaceAttr()) {
                continue;
            }
            if(attr.Name.Contains((byte)':')) {
                continue;   // TODO:
            }
            var propName = attr.Name.ToString();
            if(instanceType.TryGetMember(propName, out var propType) == false) {
                context.AddDiagnostic(DiagnosticHelper.SettableMemberNotFound(instanceType.Name, propName));
                // Skip this property
                continue;
            }
            var literal = context.XmlEntities.ResolveToString(attr.Value);
            if(propType.TryGetLiteralCode(literal, out var literalCode, out var diagnostic) == false) {
                context.AddDiagnostic(diagnostic);
                // Skip this property
                continue;
            }
            mb.AppendLine($"obj.{propName} = {literalCode};");
        }


        foreach(var childNode in node.Children) {
            if(typeStore.IsPropertyNode(childNode, out var propOwnerType, out var propName)) {
                BuildPropertyNode(childNode, instanceType, propOwnerType, propName, context, mb);
            }
            else {
                var (id, _) = GenerateFactoryMethodCode(childNode, instanceType, context);
                var contentCode = id != SkippedMethodID ? $"__F{id}(ref context, obj)" : "default!";
                if(instanceType.TryGetContentSetterCode(contentCode, out var result)) {
                    mb.AppendLine(result);
                }
                else {
                    context.AddDiagnostic(DiagnosticHelper.DirectContentNotSupported(instanceType.Name));
                    continue;
                }
            }
        }

        mb.AppendLine("return obj;");
        mb.DecrementIndent();
        mb.AppendLine(@"}
");
        return (methodId, instanceType);
    }

    private static void BuildPropertyNode(XmlNode propertyNode, TypeData instanceType, TypeData propOwnerType, RawString propName,
        MarkupTranslatorContext context,
        MethodSourceBuilder mb)
    {
        if(propOwnerType.TryGetMember(propName.ToString(), out var propType) == false) {
            context.AddDiagnostic(DiagnosticHelper.SettableMemberNotFound(instanceType.Name, propName.ToString()));
            return;
        }
        var instanceCode = (propOwnerType.Name == instanceType.Name) ? "obj" : $"((global::{propOwnerType.Name})obj)";

        if(propertyNode.Children.Count == 1) {
            var (id, _) = GenerateFactoryMethodCode(propertyNode.FirstChild.Value, instanceType, context);
            if(id != SkippedMethodID) {
                mb.AppendLine($"{instanceCode}.{propName} = __F{id}(ref context, obj);");
            }
            return;
        }
        else if(propertyNode.Children.Count == 0) {
            var literal = context.XmlEntities.ResolveToString(propertyNode.InnerText);
            if(propType.TryGetLiteralCode(literal, out var code, out var diagnostic) == false) {
                context.AddDiagnostic(diagnostic);
            }
            else {
                mb.AppendLine($"{instanceCode}.{propName} = {code};");
            }
            return;
        }
        else {
            context.AddDiagnostic(DiagnosticHelper.MutipleValuesNotSupported(instanceType.Name, propName.ToString()));
            return;
        }
    }
}
