#nullable enable
using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using U8Xml;
using Microsoft.CodeAnalysis.Text;
using System.Text;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Threading;
using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;

namespace Elffy.Generator;

[Generator]
public sealed class MarkupComponentGenerator : IIncrementalGenerator
{
    private const string SourceMarkupComponentAttribute = """
// <auto-generated>
// Auto generated by a source generator.
// Generator: Elffy.Generator.MarkupComponentGenerator
// </auto-generated>
#nullable enable
namespace Elffy.Markup;

[global::System.Diagnostics.Conditional("COMPILE_TIME_ONLY")]
[global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
internal sealed class MarkupComponentAttribute : global::System.Attribute
{
    public MarkupComponentAttribute(string markup)
    {
    }
    public MarkupComponentAttribute(string markup, string[] additionalUsings)
    {
    }
}

""";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static context =>
        {
            context.CancellationToken.ThrowIfCancellationRequested();
            context.AddSource("MarkupComponentAttribute.g.cs", SourceText.From(SourceMarkupComponentAttribute, Encoding.UTF8));
        });

        var markupComponentAttr = context.CompilationProvider.Select(static (compilation, ct) =>
        {
            ct.ThrowIfCancellationRequested();
            return compilation.GetTypeByMetadataName("Elffy.Markup.MarkupComponentAttribute") ?? throw new Exception("MarkupComponentAttribute is not found.");
        }).WithComparer(SymbolEqualityComparer.Default);

        var stringConvertible = context.CompilationProvider.Select(static (compilation, ct) =>
        {
            ct.ThrowIfCancellationRequested();
            return compilation.GetTypeByMetadataName("Elffy.Markup.IStringConvertible`1") ?? throw new Exception("Elffy.Markup.IStringConvertible`1 is not found.");
        }).WithComparer(SymbolEqualityComparer.Default);

        var sources = context
            .SyntaxProvider
            .CreateSyntaxProvider(
            static (node, ct) =>
            {
                ct.ThrowIfCancellationRequested();
                return node is ClassDeclarationSyntax { AttributeLists.Count: > 0, Modifiers.Count: > 0 };
            },
            static (context, ct) =>
            {
                ct.ThrowIfCancellationRequested();
                var semantics = context.SemanticModel;
                var classSymbol = semantics.GetDeclaredSymbol((context.Node as ClassDeclarationSyntax)!, ct);
                return (classSymbol, semantics);
            })
            .Combine(markupComponentAttr.Combine(stringConvertible).Combine(context.CompilationProvider))
            .Select(static (x, ct) =>
            {
                ct.ThrowIfCancellationRequested();
                var ((classSymbol, semantics), ((markupComponentAttr, stringConvertible), compilation)) = x;
                if(classSymbol is null) { return default; }

                AttributeData? attrData = null;
                var comparer = SymbolEqualityComparer.Default;
                foreach(var a in classSymbol.GetAttributes()) {
                    if(comparer.Equals(a.AttributeClass, markupComponentAttr)) {
                        attrData = a;
                        break;
                    }
                }
                if(attrData is null) { return default; }
                var ctorArgs = attrData.ConstructorArguments;
                if(ctorArgs.Length < 1) { return default; }
                var arg0 = ctorArgs[0];
                if(arg0.Kind != TypedConstantKind.Primitive) { return default; }

                var additionalUsings = (ctorArgs.Length >= 2 && ctorArgs[1].Kind == TypedConstantKind.Array) ?
                    ctorArgs[1].Values
                        .Select(x => x.Value?.ToString() ?? "")
                        .Where(x => !string.IsNullOrEmpty(x))
                        .ToImmutableArray() :
                    ImmutableArray<string>.Empty;

                var markupString = arg0.Value?.ToString() ?? "";

                var classFullName = classSymbol.GetTypeName();
                var i = classFullName.LastIndexOf('.');
                var (ns, className) = (classFullName.Substring(0, i), classFullName.Substring(i + 1));
                return new MarkupAttrData(ns, className, markupString, additionalUsings, stringConvertible, compilation);
            })
            .Where(static x => x is not null)!
            .WithComparer(EqualityComparer<MarkupAttrData>.Default)
            .Select(static (markup, ct) => TranslateMarkup(markup!, ct));

        context.RegisterSourceOutput(sources, static (context, source) =>
        {
            context.CancellationToken.ThrowIfCancellationRequested();
            var sourceText = SourceText.From(source.SourceCode, Encoding.UTF8);
            context.AddSource(source.Name + ".g.cs", sourceText);
        });
    }

    private static SourceData TranslateMarkup(MarkupAttrData markup, CancellationToken ct)
    {
        ct.ThrowIfCancellationRequested();
        using var xml = XmlParser.Parse(markup.MarkupString);
        ImmutableArray<string> usings = ImmutableArray.Create(new[]
        {
            "System",
            "System.Runtime.CompilerServices",
            "System.Diagnostics",
            "Cysharp.Threading.Tasks",
            "Elffy",
            "Elffy.UI",
            "Elffy.Markup",
            "Elffy.Threading",
        }).AddRange(markup.AdditionalUsings);
        var sb = new StringBuilder();
        var context = new TranslationContext(sb, xml, markup, usings, ct);

        context.Sb.AppendLine("""
            // <auto-generated>
            // Auto generated by a source generator.
            // Generator: Elffy.Generator.MarkupComponentGenerator
            // </auto-generated>
            
            #nullable enable
            """);
        foreach(var u in usings) {
            context.Sb.AppendLine($"""
            using {u};
            """);
        }
        context.Sb.AppendLine($$"""
            namespace {{markup.Namespace}}
            {
                partial class {{markup.ClassName}}
                {
                    private {{markup.ClassName}}() { }

                    partial void OnCreated();

                    public static async UniTask<{{markup.ClassName}}> Create(Control parent)
                    {
                        ArgumentNullException.ThrowIfNull(parent);
                        var component = new {{markup.ClassName}}();
                        using var tasks = new ParallelOperation();
                        Builder.__F0(parent, tasks, component);
                        await tasks.WhenAll();
                        component.OnCreated();
                        return component;
                    }
                
            """);
        var propertyPosition = context.Sb.Length;

        context.Sb.AppendLine($$"""
                }

                file static class Builder
                {
            """);

        foreach(var node in xml.GetAllNodes()) {
            WriteNode(node, context, propertyPosition);
        }

        context.Sb.AppendLine($$"""
                }
            }
            """);

        return context.ToSourceData();
    }

    private static bool TryGetTypeSymbol(
        XmlNode node,
        in TranslationContext context,
        [MaybeNullWhen(false)] out INamedTypeSymbol typeSymbol,
        [MaybeNullWhen(false)] out string fullName)
    {
        var compilation = context.Markup.Compilation;
        var nodeName = node.Name.ToString();
        var possibleFullNames = PossibleFullNames(context.Markup.Namespace, nodeName, context.Usings);
        foreach(var possibleFullName in possibleFullNames) {
            typeSymbol = compilation.GetTypeByMetadataName(possibleFullName);
            if(typeSymbol != null) {
                fullName = possibleFullName;
                return true;
            }
        }
        typeSymbol = null;
        fullName = null;
        return false;

        static IEnumerable<string> PossibleFullNames(string declaredNamespace, string name, ImmutableArray<string> usings)
        {
            var splits = declaredNamespace.Split('.');
            var nameAsArray = new string[] { name };
            for(int i = 0; i < splits.Length; i++) {
                yield return string.Join(".", splits.Take(splits.Length - i).Concat(nameAsArray));
            }
            foreach(var u in usings) {
                yield return $"{u}.{name}";
            }
        }
    }

    private static bool TryGetMemberType(INamedTypeSymbol typeSymbol, string memberName, [MaybeNullWhen(false)] out ITypeSymbol memberType)
    {
        var current = typeSymbol;
        while(current != null) {
            var members = current.GetMembers(memberName);
            if(members.Length > 0) {
                if(members[0] is IPropertySymbol prop) {
                    memberType = prop.Type;
                    return true;
                }
                if(members[0] is IFieldSymbol field) {
                    memberType = field.Type;
                    return true;
                }
            }
            current = current.BaseType;
        }
        memberType = null;
        return false;
    }

    private static void WriteNode(XmlNode node, in TranslationContext context, int propertyPosition)
    {
        var interfaceSymbol = context.Markup.StringConvertible;

        string? typeFullName;
        INamedTypeSymbol typeSymbol;
        if(node.TryGetFullName(out var ns, out var name)) {
            typeFullName = $"{ns}.{name}";
            typeSymbol = context.Markup.Compilation.GetTypeByMetadataName(typeFullName) ?? throw new Exception();
        }
        else if(TryGetTypeSymbol(node, context, out typeSymbol, out typeFullName) == false) {
            throw new Exception();
        }

        context.Sb.AppendLine($$"""
                    public static void __F{{context.NodeIndex[node]}}(Control parent, ParallelOperation tasks, {{context.Markup.ClassName}} component)
                    {
                        var obj = new {{typeFullName}}();
            """);

        var reactiveProps = new List<string>();
        foreach(var (attrName, attrValue) in node.Attributes) {
            if(attrName == "_name_"u8) {
                context.Sb.Insert(propertyPosition, $$"""
                        private {{typeFullName}} _{{attrValue}} = default!;
                        public {{typeFullName}} {{attrValue}} => _{{attrValue}};

                """);
                //context.Sb.AppendLine($$"""
                //            component._{{attrValue}} = obj;
                //""");
            }
            else {
                if(TryGetMemberType(typeSymbol, attrName.ToString(), out var memberType) == false) { throw new Exception(); }

                var isStringConvertible = memberType.Interfaces.Any(x =>
                {
                    var eq = SymbolEqualityComparer.Default;
                    return eq.Equals(x.ConstructedFrom, interfaceSymbol) && eq.Equals(x.TypeArguments[0], memberType);
                });
                var isReactive = attrValue.StartsWith("{"u8) && attrValue.EndsWith("}"u8);

                if(isStringConvertible) {
                    context.Sb.AppendLine($$""""
                        obj.{{attrName}} = {{memberType.GetTypeName()}}.Convert("""{{attrValue}}""");
            """");
                }
                else {
                    context.Sb.AppendLine($$""""
                        obj.{{attrName}} = Elffy.Markup.StringConverter<{{memberType.GetTypeName()}}>.Convert("""{{attrValue}}""");
            """");
                }
            }
        }

        context.Sb.AppendLine($$"""
                        tasks.Add(parent.Children.Add(obj));
            """);
        foreach(var c in node.Children) {
            context.Sb.AppendLine($$"""
                        __F{{context.NodeIndex[c]}}(obj, tasks, component);
            """);
        }
        context.Sb.AppendLine("""
                    }

            """);
    }

    private readonly struct TranslationContext
    {
        public TranslationContext(
            StringBuilder sb,
            XmlObject xml,
            MarkupAttrData markup,
            ImmutableArray<string> usings,
            CancellationToken ct)
        {
            var allNodes = xml.GetAllNodes();
            var nodeIndex = new Dictionary<XmlNode, int>(allNodes.Count);
            var i = 0;
            foreach(var node in allNodes) {
                nodeIndex.Add(node, i);
                i++;
            }
            Sb = sb;
            Xml = xml;
            NodeIndex = nodeIndex;
            Markup = markup;
            Usings = usings;
            Ct = ct;
        }

        public StringBuilder Sb { get; }
        public XmlObject Xml { get; }
        public Dictionary<XmlNode, int> NodeIndex { get; }
        public MarkupAttrData Markup { get; }
        public ImmutableArray<string> Usings { get; }
        public CancellationToken Ct { get; }

        public SourceData ToSourceData()
        {
            return new SourceData(Markup.ClassName, Sb.ToString());
        }
    }

    private record MarkupAttrData(string Namespace, string ClassName, string MarkupString, ImmutableArray<string> AdditionalUsings, INamedTypeSymbol StringConvertible, Compilation Compilation)
    {
        public string ClassFullName => $"{Namespace}.{ClassName}";
    }

    private record SourceData(string Name, string SourceCode);
}
