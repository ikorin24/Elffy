#nullable enable
using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using U8Xml;
using Microsoft.CodeAnalysis.Text;
using System.Text;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Threading;

namespace Elffy.Generator;

[Generator]
public sealed class MarkupComponentGenerator : IIncrementalGenerator
{
    private const string SourceMarkupComponentAttribute = """
// <auto-generated>
// Auto generated by a source generator.
// Generator: Elffy.Generator.MarkupComponentGenerator
// </auto-generated>
#nullable enable
namespace Elffy.Markup;

[global::System.Diagnostics.Conditional("COMPILE_TIME_ONLY")]
[global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
internal sealed class MarkupComponentAttribute : global::System.Attribute
{
    public MarkupComponentAttribute(string markup)
    {
    }
    public MarkupComponentAttribute(string markup, string[] additionalUsings)
    {
    }
}

""";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static context =>
        {
            context.CancellationToken.ThrowIfCancellationRequested();
            context.AddSource("MarkupComponentAttribute.g.cs", SourceText.From(SourceMarkupComponentAttribute, Encoding.UTF8));
        });

        var markupComponentAttr = context.CompilationProvider.Select(static (compilation, ct) =>
        {
            ct.ThrowIfCancellationRequested();
            return compilation.GetTypeByMetadataName("Elffy.Markup.MarkupComponentAttribute") ?? throw new Exception("MarkupComponentAttribute is not found.");
        }).WithComparer(SymbolEqualityComparer.Default);

        var sources = context
            .SyntaxProvider
            .CreateSyntaxProvider(
            static (node, ct) =>
            {
                ct.ThrowIfCancellationRequested();
                return node is ClassDeclarationSyntax { AttributeLists.Count: > 0, Modifiers.Count: > 0 };
            },
            static (context, ct) =>
            {
                ct.ThrowIfCancellationRequested();
                var semantics = context.SemanticModel;
                var classSymbol = semantics.GetDeclaredSymbol((context.Node as ClassDeclarationSyntax)!, ct);
                return (classSymbol, semantics);
            })
            .Combine(markupComponentAttr)
            .Select(static (x, ct) =>
            {
                ct.ThrowIfCancellationRequested();
                var ((classSymbol, semantics), markupComponentAttr) = x;
                if(classSymbol is null) { return default; }

                AttributeData? attrData = null;
                var comparer = SymbolEqualityComparer.Default;
                foreach(var a in classSymbol.GetAttributes()) {
                    if(comparer.Equals(a.AttributeClass, markupComponentAttr)) {
                        attrData = a;
                        break;
                    }
                }
                if(attrData is null) { return default; }
                if(attrData.ConstructorArguments.Length < 1) { return default; }
                var arg0 = attrData.ConstructorArguments[0];
                if(arg0.Kind != TypedConstantKind.Primitive) { return default; }

                var markupString = arg0.Value?.ToString() ?? "";

                var classFullName = classSymbol.GetTypeName();
                var i = classFullName.LastIndexOf('.');
                var (ns, className) = (classFullName.Substring(0, i), classFullName.Substring(i + 1));
                return new MarkupAttrData(ns, className, markupString);
            })
            .Where(static x => x is not null)!
            .WithComparer(EqualityComparer<MarkupAttrData>.Default)
            .Select(static (markup, ct) => TranslateMarkup(markup!, ct));

        context.RegisterSourceOutput(sources, static (context, source) =>
        {
            context.CancellationToken.ThrowIfCancellationRequested();
            var sourceText = SourceText.From(source.SourceCode, Encoding.UTF8);
            context.AddSource(source.Name + ".g.cs", sourceText);
        });
    }

    private static SourceData TranslateMarkup(MarkupAttrData markup, CancellationToken ct)
    {
        ct.ThrowIfCancellationRequested();

        using var xml = XmlParser.Parse(markup.MarkupString);
        var sb = new StringBuilder();
        var context = new TranslationContext(sb, xml, markup, ct);
        context.Sb.AppendLine($$"""
            // <auto-generated>
            // Auto generated by a source generator.
            // Generator: Elffy.Generator.MarkupComponentGenerator
            // </auto-generated>
            
            #nullable enable
            using System;
            using System.Runtime.CompilerServices;
            using System.Diagnostics;
            using Cysharp.Threading.Tasks;
            using Elffy;
            using Elffy.UI;
            using Elffy.Markup;
            using Elffy.Threading;
            using __Hidden;
            namespace {{markup.Namespace}}
            {
                partial class {{markup.ClassName}}
                {
                    private {{markup.ClassName}}() { }

                    partial void OnCreated();

                    public static async UniTask<{{markup.ClassName}}> Create(Control parent)
                    {
                        ArgumentNullException.ThrowIfNull(parent);
                        var component = new {{markup.ClassName}}();
                        using var tasks = new ParallelOperation();
                        Builder.__F0(parent, tasks, component);
                        await tasks.WhenAll();
                        component.OnCreated();
                        return component;
                    }
                
            """);
        var propertyPosition = context.Sb.Length;

        context.Sb.AppendLine($$"""
                }

                file static class Builder
                {
            """);

        foreach(var node in xml.GetAllNodes()) {
            WriteNode(node, context, propertyPosition);
        }

        context.Sb.AppendLine($$"""
                }

                file static class HighPriorityExtensions
                {
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    [DebuggerHidden]
                    public static T __ConvertIntoTypeOf<T>(this string s, in T _) where T : IStringConvertible<T>
                        => T.Convert(s);
                }
            }

            namespace __Hidden
            {
                file static class LowPriorityExtensions
                {
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    [DebuggerHidden]
                    public static T __ConvertIntoTypeOf<T>(this string s, in T _) => StringConverter<T>.Convert(s);
                }
            }
            """);

        return context.ToSourceData();
    }

    private static void WriteNode(XmlNode node, in TranslationContext context, int propertyPosition)
    {
        var typeName = node.TryGetFullName(out var ns, out var name) ? $"{ns}.{name}" : node.Name.ToString();

        context.Sb.AppendLine($$"""
                    public static void __F{{context.NodeIndex[node]}}(Control parent, ParallelOperation tasks, {{context.Markup.ClassName}} component)
                    {
                        var obj = new {{typeName}}();
            """);

        var reactiveProps = new List<string>();
        foreach(var (attrName, attrValue) in node.Attributes) {
            if(attrName == "_name_"u8) {
            //    context.Sb.Insert(propertyPosition, $$"""
            //        private object _{{attrValue}} = default!;
            //        public object {{attrValue}} => _{{attrValue}};

            //""");
            //    context.Sb.AppendLine($$"""
            //            component._{{attrValue}} = obj;
            //""");
            }
            else if(attrValue.StartsWith("{"u8) && attrValue.EndsWith("}"u8)) {
                context.Sb.AppendLine($$""""
                        obj.{{attrName}} = """{{attrValue}}""".__ConvertIntoTypeOf(obj.{{attrName}});   // TODO: reactive
            """");
            }
            else {
                context.Sb.AppendLine($$""""
                        obj.{{attrName}} = """{{attrValue}}""".__ConvertIntoTypeOf(obj.{{attrName}});
            """");
            }
        }

        context.Sb.AppendLine($$"""
                        tasks.Add(parent.Children.Add(obj));
            """);
        foreach(var c in node.Children) {
            context.Sb.AppendLine($$"""
                        __F{{context.NodeIndex[c]}}(parent, tasks, component);
            """);
        }
        context.Sb.AppendLine("""
                    }

            """);
    }

    private readonly struct TranslationContext
    {
        public TranslationContext(
            StringBuilder sb,
            XmlObject xml,
            MarkupAttrData markup,
            CancellationToken ct)
        {
            var allNodes = xml.GetAllNodes();
            var nodeIndex = new Dictionary<XmlNode, int>(allNodes.Count);
            var i = 0;
            foreach(var node in allNodes) {
                nodeIndex.Add(node, i);
                i++;
            }
            Sb = sb;
            Xml = xml;
            NodeIndex = nodeIndex;
            Markup = markup;
            Ct = ct;
        }

        public StringBuilder Sb { get; }
        public XmlObject Xml { get; }
        public Dictionary<XmlNode, int> NodeIndex { get; }
        public MarkupAttrData Markup { get; }
        public CancellationToken Ct { get; }

        public SourceData ToSourceData()
        {
            return new SourceData(Markup.ClassName, Sb.ToString());
        }
    }

    private record MarkupAttrData(string Namespace, string ClassName, string MarkupString);

    private record SourceData(string Name, string SourceCode);
}
