#nullable enable
using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using U8Xml;
using Microsoft.CodeAnalysis.Text;
using System.Text;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Threading;
using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;

namespace Elffy.Generator;

[Generator]
public sealed class MarkupComponentGenerator : IIncrementalGenerator
{
    private const string SourceMarkupComponentAttribute = """
// <auto-generated>
// Auto generated by a source generator.
// Generator: Elffy.Generator.MarkupComponentGenerator
// </auto-generated>
#nullable enable
namespace Elffy.Markup;

[global::System.Diagnostics.Conditional("COMPILE_TIME_ONLY")]
[global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
internal sealed class MarkupComponentAttribute : global::System.Attribute
{
    public MarkupComponentAttribute(string markup)
    {
    }
    public MarkupComponentAttribute(string markup, string[] additionalUsings)
    {
    }
}

""";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static context =>
        {
            context.CancellationToken.ThrowIfCancellationRequested();
            context.AddSource("MarkupComponentAttribute.g.cs", SourceText.From(SourceMarkupComponentAttribute, Encoding.UTF8));
        });

        var markupComponentAttr = context.CompilationProvider.Select(static (compilation, ct) =>
        {
            ct.ThrowIfCancellationRequested();
            return compilation.GetTypeByMetadataName("Elffy.Markup.MarkupComponentAttribute") ?? throw new Exception("MarkupComponentAttribute is not found.");
        }).WithComparer(SymbolEqualityComparer.Default);

        var stringConvertible = context.CompilationProvider.Select(static (compilation, ct) =>
        {
            ct.ThrowIfCancellationRequested();
            return compilation.GetTypeByMetadataName("Elffy.Markup.IStringConvertible`1") ?? throw new Exception("Elffy.Markup.IStringConvertible`1 is not found.");
        }).WithComparer(SymbolEqualityComparer.Default);

        var sources = context
            .SyntaxProvider
            .CreateSyntaxProvider(
            static (node, ct) =>
            {
                ct.ThrowIfCancellationRequested();
                return node is ClassDeclarationSyntax { AttributeLists.Count: > 0, Modifiers.Count: > 0 };
            },
            static (context, ct) =>
            {
                ct.ThrowIfCancellationRequested();
                var semantics = context.SemanticModel;
                var classSymbol = semantics.GetDeclaredSymbol((context.Node as ClassDeclarationSyntax)!, ct);
                return (classSymbol, semantics);
            })
            .Combine(markupComponentAttr.Combine(stringConvertible).Combine(context.CompilationProvider))
            .Select(static (x, ct) =>
            {
                ct.ThrowIfCancellationRequested();
                var ((classSymbol, semantics), ((markupComponentAttr, stringConvertible), compilation)) = x;
                if(classSymbol is null) { return default; }

                AttributeData? attrData = null;
                var comparer = SymbolEqualityComparer.Default;
                foreach(var a in classSymbol.GetAttributes()) {
                    if(comparer.Equals(a.AttributeClass, markupComponentAttr)) {
                        attrData = a;
                        break;
                    }
                }
                if(attrData is null) { return default; }
                var ctorArgs = attrData.ConstructorArguments;
                if(ctorArgs.Length < 1) { return default; }
                var arg0 = ctorArgs[0];
                if(arg0.Kind != TypedConstantKind.Primitive) { return default; }

                var additionalUsings = (ctorArgs.Length >= 2 && ctorArgs[1].Kind == TypedConstantKind.Array) ?
                    ctorArgs[1].Values
                        .Select(x => x.Value?.ToString() ?? "")
                        .Where(x => !string.IsNullOrEmpty(x))
                        .ToImmutableArray() :
                    ImmutableArray<string>.Empty;

                var markupString = arg0.Value?.ToString() ?? "";

                var classFullName = classSymbol.GetTypeName();
                var i = classFullName.LastIndexOf('.');
                var (ns, className) = (classFullName.Substring(0, i), classFullName.Substring(i + 1));
                return new MarkupAttrData(ns, className, markupString, additionalUsings, stringConvertible, compilation);
            })
            .Where(static x => x is not null)!
            .WithComparer(EqualityComparer<MarkupAttrData>.Default)
            .Select(static (markup, ct) => TranslateMarkup(markup!, ct));

        context.RegisterSourceOutput(sources, static (context, source) =>
        {
            context.CancellationToken.ThrowIfCancellationRequested();
            var sourceText = SourceText.From(source.SourceCode, Encoding.UTF8);
            context.AddSource(source.Name + ".g.cs", sourceText);
        });
    }

    private static SourceData TranslateMarkup(MarkupAttrData markup, CancellationToken ct)
    {
        ct.ThrowIfCancellationRequested();
        using var xml = XmlParser.Parse(markup.MarkupString);
        ImmutableArray<string> usings = ImmutableArray.Create(new[]
        {
            "System",
            "System.Runtime.CompilerServices",
            "System.Diagnostics",
            "Cysharp.Threading.Tasks",
            "Elffy",
            "Elffy.UI",
            "Elffy.Markup",
            "Elffy.Threading",
        }).AddRange(markup.AdditionalUsings);
        var context = new TranslationContext(xml, markup, usings, ct);

        context.Sb.AppendLine("""
            // <auto-generated>
            // Auto generated by a source generator.
            // Generator: Elffy.Generator.MarkupComponentGenerator
            // </auto-generated>
            
            #nullable enable
            """);
        foreach(var u in usings) {
            context.Sb.AppendLine($"""
            using {u};
            """);
        }
        context.Sb.AppendLine($$"""
            namespace {{markup.Namespace}}
            {
                partial class {{markup.ClassName}} : Elffy.Markup.IMarkupComponent<{{markup.ClassName}}, Control>
                {
                    private {{markup.ClassName}}() { }

                    partial void OnCreated();

                    public static UniTask<{{markup.ClassName}}> Create(Control parent)
                    {
                        ArgumentNullException.ThrowIfNull(parent);
                        var component = new {{markup.ClassName}}();
                        using var tasks = new ParallelOperation();
                        var state = new __BuilderState
                        {
                            Tasks = tasks,
                            Component = component,
            """);
        var fieldrefSetPosition = context.Sb.Length;
        context.Sb.AppendLine($$"""
                        };
                        __Builder.Build(ref state, ref parent);
                        return WaitForBuildCompletion(component, tasks.WhenAll());
            
                        static async UniTask<{{markup.ClassName}}> WaitForBuildCompletion({{markup.ClassName}} component, UniTask allTasks)
                        {
                            await allTasks;
                            component.OnCreated();
                            return component;
                        }
                    }
            
            """);
        var memberPosition = context.Sb.Length;

        context.Sb.AppendLine($$"""
                }
            
                file ref struct __BuilderState
                {
                    public ParallelOperation Tasks;
                    public {{context.Markup.ClassName}} Component;
            """);

        var fieldrefPosition = context.Sb.Length;
        context.Sb.AppendLine($$"""
                }

                file static class __Builder
                {
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    public static void Build(ref __BuilderState state, ref Control parent)
                    {
                        __Builder.__F0(parent, ref state);
                    }
            """);

        foreach(var node in xml.GetAllNodes()) {
            WriteNode(node, context);
        }

        context.Sb.Insert(fieldrefPosition, context.FieldrefSb.ToString());
        context.Sb.Insert(memberPosition, context.MemberSb.ToString());
        context.Sb.Insert(fieldrefSetPosition, context.FieldrefSetSb.ToString());

        context.Sb.AppendLine($$"""
                }
            }
            """);

        return new SourceData(context.Markup.ClassName, context.Sb.ToString());
    }

    private static bool TryGetTypeSymbol(
        XmlNode node,
        in TranslationContext context,
        [MaybeNullWhen(false)] out INamedTypeSymbol typeSymbol,
        [MaybeNullWhen(false)] out string fullName)
    {
        var compilation = context.Markup.Compilation;
        var nodeName = node.Name.ToString();
        var possibleFullNames = PossibleFullNames(context.Markup.Namespace, nodeName, context.Usings);
        foreach(var possibleFullName in possibleFullNames) {
            typeSymbol = compilation.GetTypeByMetadataName(possibleFullName);
            if(typeSymbol != null) {
                fullName = possibleFullName;
                return true;
            }
        }
        typeSymbol = null;
        fullName = null;
        return false;

        static IEnumerable<string> PossibleFullNames(string declaredNamespace, string name, ImmutableArray<string> usings)
        {
            var splits = declaredNamespace.Split('.');
            var nameAsArray = new string[] { name };
            for(int i = 0; i < splits.Length; i++) {
                yield return string.Join(".", splits.Take(splits.Length - i).Concat(nameAsArray));
            }
            foreach(var u in usings) {
                yield return $"{u}.{name}";
            }
        }
    }

    private static bool TryGetMemberType(INamedTypeSymbol typeSymbol, string memberName, [MaybeNullWhen(false)] out ITypeSymbol memberType)
    {
        var current = typeSymbol;
        while(current != null) {
            var members = current.GetMembers(memberName);
            if(members.Length > 0) {
                if(members[0] is IPropertySymbol prop) {
                    memberType = prop.Type;
                    return true;
                }
                if(members[0] is IFieldSymbol field) {
                    memberType = field.Type;
                    return true;
                }
            }
            current = current.BaseType;
        }
        memberType = null;
        return false;
    }

    private static (string? ComponentFieldName, string? PropertyAccessibility, string? PropertyName) GetCacheFieldName(XmlNode node, in TranslationContext context)
    {
        string? componentFieldName = null;
        string? propertyAccessibility = null;
        string? propName = null;
        if(node.Attributes.TryFind("__name"u8, out var nameAttribute)) {
            var (_, attrValue) = nameAttribute;
            componentFieldName = $"__{attrValue}";
            propertyAccessibility = "public";
            propName = attrValue.ToString();
        }
        else if(ContainsReactiveBind(node.Attributes)) {
            componentFieldName = $"____unnamed{context.NodeIndex[node]}";
            propertyAccessibility = null;
            propName = null;
        }
        return (componentFieldName, propertyAccessibility, propName);

        static bool ContainsReactiveBind(XmlAttributeList attributes)
        {
            var isReactiveBound = false;
            foreach(var (attrName, attrValue) in attributes) {
                if(attrValue.StartsWith("{"u8) && attrValue.EndsWith("}"u8)) {
                    isReactiveBound = true;
                }
            }
            return isReactiveBound;
        }
    }

    private static void WriteNode(XmlNode node, in TranslationContext context)
    {
        var interfaceSymbol = context.Markup.StringConvertible;
        var nodeIndex = context.NodeIndex[node];

        string? typeFullName;
        INamedTypeSymbol? typeSymbol;

        {
            if(node.TryGetFullName(out var ns, out var nodeName)) {
                typeFullName = $"{ns}.{nodeName}";
                typeSymbol = context.Markup.Compilation.GetTypeByMetadataName(typeFullName) ?? throw new Exception();
            }
            else {
                if(TryGetTypeSymbol(node, context, out typeSymbol, out typeFullName) == false) {
                    throw new Exception();
                }
            }
        }

        context.Sb.AppendLine($$"""
                    private static void __F{{nodeIndex}}(Control parent, ref __BuilderState state)
                    {
            """);

        var (componentFieldName, propertyAccessibility, propertyName) = GetCacheFieldName(node, context);
        if(componentFieldName != null) {
            context.MemberSb.AppendLine($$"""
                    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                    private {{typeFullName}} {{componentFieldName}} = default!;
            """);
            if(propertyName != null) {
                context.MemberSb.AppendLine($$"""
                    {{propertyAccessibility}} {{typeFullName}} {{propertyName}} => {{componentFieldName}};
            """);
            }
            context.FieldrefSb.AppendLine($$"""
                    public ref {{typeFullName}} {{componentFieldName}};
            """);
            context.FieldrefSetSb.AppendLine($$"""
                            {{componentFieldName}} = ref component.{{componentFieldName}},
            """);
        }

        if(componentFieldName != null) {
            context.Sb.AppendLine($$"""
                        ref var obj = ref state.{{componentFieldName}};
            """);
        }
        else {
            context.Sb.AppendLine($$"""
                        {{typeFullName}} obj;
            """);
        }

        context.Sb.AppendLine($$"""
                        obj = new {{typeFullName}}();
            """);

        foreach(var (attrName, attrValue) in node.Attributes) {
            if(attrName == "__name"u8) { continue; }
            else {
                if(TryGetMemberType(typeSymbol, attrName.ToString(), out var memberType) == false) { throw new Exception(); }

                var isStringConvertible = memberType.Interfaces.Any(x =>
                {
                    var eq = SymbolEqualityComparer.Default;
                    return eq.Equals(x.ConstructedFrom, interfaceSymbol) && eq.Equals(x.TypeArguments[0], memberType);
                });

                if(attrValue.StartsWith("{"u8) && attrValue.EndsWith("}"u8)) {
                    var (reactivePropName, reactiveOption) = attrValue.Slice(1, attrValue.Length - 2).Split2((byte)':');

                    context.MemberSb.AppendLine($$"""
                    public {{memberType.GetTypeName()}} {{reactivePropName}}
                    {
                        get => {{componentFieldName}}.{{attrName}};
                        set
                        {
                            if(System.Collections.Generic.EqualityComparer<{{memberType.GetTypeName()}}>.Default.Equals({{reactivePropName}}, value)) {
                                return;
                            }
                            {{componentFieldName}}.{{attrName}} = value;
                        }
                    }
            """);
                }

                if(isStringConvertible) {
                    context.Sb.AppendLine($$""""
                        obj.{{attrName}} = {{memberType.GetTypeName()}}.Convert("""{{attrValue}}""");
            """");
                }
                else {
                    context.Sb.AppendLine($$""""
                        obj.{{attrName}} = Elffy.Markup.StringConverter<{{memberType.GetTypeName()}}>.Convert("""{{attrValue}}""");
            """");
                }
            }
        }

        context.Sb.AppendLine($$"""
                        state.Tasks.Add(parent.Children.Add(obj));
            """);
        foreach(var c in node.Children) {
            context.Sb.AppendLine($$"""
                        __F{{context.NodeIndex[c]}}(obj, ref state);
            """);
        }
        context.Sb.AppendLine("""
                    }

            """);
    }

    private readonly struct TranslationContext
    {
        public TranslationContext(
            XmlObject xml,
            MarkupAttrData markup,
            ImmutableArray<string> usings,
            CancellationToken ct)
        {
            var allNodes = xml.GetAllNodes();
            var nodeIndex = new Dictionary<XmlNode, int>(allNodes.Count);
            var i = 0;
            foreach(var node in allNodes) {
                nodeIndex.Add(node, i);
                i++;
            }
            Sb = new StringBuilder();
            MemberSb = new StringBuilder();
            FieldrefSetSb = new StringBuilder();
            FieldrefSb = new StringBuilder();
            Xml = xml;
            NodeIndex = nodeIndex;
            Markup = markup;
            Usings = usings;
            Ct = ct;
        }

        public StringBuilder Sb { get; }
        public StringBuilder MemberSb { get; }
        public StringBuilder FieldrefSetSb { get; }
        public StringBuilder FieldrefSb { get; }
        public XmlObject Xml { get; }
        public Dictionary<XmlNode, int> NodeIndex { get; }
        public MarkupAttrData Markup { get; }
        public ImmutableArray<string> Usings { get; }
        public CancellationToken Ct { get; }
    }

    private record MarkupAttrData(string Namespace, string ClassName, string MarkupString, ImmutableArray<string> AdditionalUsings, INamedTypeSymbol StringConvertible, Compilation Compilation)
    {
        public string ClassFullName => $"{Namespace}.{ClassName}";
    }

    private record SourceData(string Name, string SourceCode);
}
