#nullable enable
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Linq;
using System.Text;
using System.Collections.Generic;
using System;
using System.Collections.Immutable;
using System.Threading;

namespace Elffy.Generator;

[Generator]
public sealed class ResourcesGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static context =>
        {
            const string S =
@"// <auto-generated>
// Auto generated by a source generator.
// Generator: Elffy.Generator.ResourcesGenerator
// </auto-generated>
#nullable enable

namespace Elffy
{
    [global::System.Diagnostics.Conditional(""COMPILE_TIME_ONLY"")]
    [global::System.AttributeUsage(global::System.AttributeTargets.Assembly, AllowMultiple = true, Inherited = false)]
    internal sealed class DefineLocalResourceAttribute : global::System.Attribute
    {
        public DefineLocalResourceAttribute(string importedName, string packageFilePath)
        {
        }
    }
}
";
            context.AddSource("DefineLocalResourceAttribute.g.cs", S);
        });

        var defineLocalResourceAttrClass = context
            .CompilationProvider
            .Select(static (compilation, ct) =>
            {
                ct.ThrowIfCancellationRequested();
                return compilation.GetTypeByMetadataName("Elffy.DefineLocalResourceAttribute") ?? throw new Exception("DefineLocalResourceAttribute is not found.");
            })
            .WithComparer(SymbolEqualityComparer.Default);

        var localResourceInfo = context.CompilationProvider
            .Combine(defineLocalResourceAttrClass)
            .Select(static (x, ct) =>
            {
                ct.ThrowIfCancellationRequested();
                var (compilation, targetAttrClass) = x;
                return Enumerate(compilation, targetAttrClass, ct).ToImmutableArray();

                static IEnumerable<LocalResourceInfo> Enumerate(Compilation compilation, INamedTypeSymbol targetAttrClass, CancellationToken ct)
                {
                    var comparer = SymbolEqualityComparer.Default;
                    foreach(var a in compilation.Assembly.GetAttributes()) {
                        ct.ThrowIfCancellationRequested();
                        if(comparer.Equals(a.AttributeClass, targetAttrClass) == false) { continue; }
                        yield return new()
                        {
                            ImportedName = a.ConstructorArguments[0].Value?.ToString() ?? throw new Exception(),
                            Path = a.ConstructorArguments[1].Value?.ToString() ?? throw new Exception(),
                        };
                    }
                }
            })
            .WithComparer(ImmutableArraySequenceEqualityComparer<LocalResourceInfo>.Default);

        context.RegisterSourceOutput(localResourceInfo, static (context, infoList) =>
        {
            var ct = context.CancellationToken;
            ct.ThrowIfCancellationRequested();
            var sb = new StringBuilder();
            CreateSource(infoList, sb, ct);
            ct.ThrowIfCancellationRequested();
            context.AddSource("Resources.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        });
    }

    private static void CreateSource(ImmutableArray<LocalResourceInfo> infoList, StringBuilder sb, CancellationToken ct)
    {
        ct.ThrowIfCancellationRequested();

        sb.Append(
@"// <auto-generated>
// Auto generated by a source generator.
// Generator: Elffy.Generator.ResourcesGenerator
// </auto-generated>

#nullable enable

namespace Elffy
{
    /// <summary>Provides resource packages</summary>
    internal static partial class Resources
    {
");

        foreach(var info in infoList) {
            sb.AppendLine(
$@"        /// <summary>Get resource package ""{info.ImportedName}""</summary>
        public static global::Elffy.IResourcePackage {info.ImportedName} {{ get; }} = global::Elffy.ResourcePackageProvider.CreateLocalResourcePackage(""{info.ImportedName}"", ""{info.Path}"");");
        }

        sb.Append(@"
    }
}
");
    }

    private record struct LocalResourceInfo
    {
        public string ImportedName { get; init; } = "";
        public string Path { get; init; } = "";
    }

    private sealed class ImmutableArraySequenceEqualityComparer<T> : IEqualityComparer<ImmutableArray<T>>
    {
        public static readonly ImmutableArraySequenceEqualityComparer<T> Default = new();

        public bool Equals(ImmutableArray<T> x, ImmutableArray<T> y) => x.SequenceEqual(y);

        public int GetHashCode(ImmutableArray<T> obj)
        {
            var hash = obj.Length;
            foreach(var item in obj) {
                hash += item?.GetHashCode() ?? 0;
            }
            return hash;
        }
    }
}
