#nullable enable
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using System;
using System.Collections.Immutable;

namespace Elffy.Generator;

[Generator]
public sealed class EnumLikeStructGenerator : IIncrementalGenerator
{
    private const string SourceGenerateEnumLikeStructAttribute =
@"// <auto-generated>
// Auto generated by a source generator.
// Generator: Elffy.Generator.EnumLikeStructGenerator
// </auto-generated>

#nullable enable

namespace Elffy
{
    [global::System.Diagnostics.Conditional(""COMPILE_TIME_ONLY"")]
    [global::System.AttributeUsage(global::System.AttributeTargets.Struct, AllowMultiple = false, Inherited = false)]
    internal sealed class GenerateEnumLikeStructAttribute : global::System.Attribute
    {
        public GenerateEnumLikeStructAttribute(global::System.Type underlyingType)
        {
        }
    }
}
";
    private const string SourceEnumLikeValueAttribute =
@"// <auto-generated>
// Auto generated by a source generator.
// Generator: Elffy.Generator.EnumLikeStructGenerator
// </auto-generated>

#nullable enable

namespace Elffy
{
    [global::System.Diagnostics.Conditional(""COMPILE_TIME_ONLY"")]
    [global::System.AttributeUsage(global::System.AttributeTargets.Struct, AllowMultiple = true, Inherited = false)]
    internal sealed class EnumLikeValueAttribute : global::System.Attribute
    {
        public EnumLikeValueAttribute(string name, long value)
        {
        }

        public EnumLikeValueAttribute(string name, ulong value)
        {
        }

        public EnumLikeValueAttribute(string name, long value, string accessibility)
        {
        }

        public EnumLikeValueAttribute(string name, ulong value, string accessibility)
        {
        }

        public EnumLikeValueAttribute(string name, long value, string accessibility, string description)
        {
        }

        public EnumLikeValueAttribute(string name, ulong value, string accessibility, string description)
        {
        }
    }
}
";
    private const string SourceEnumLikeMembers =
@"// <auto-generated>
// Auto generated by a source generator.
// Generator: Elffy.Generator.EnumLikeStructGenerator
// </auto-generated>

#nullable enable

namespace Elffy
{
    [global::System.Diagnostics.DebuggerDisplay(""EnumLikeMembers<{typeof(T).Name,nq}>[{Length}]"")]
#pragma warning disable CS0618
    [global::System.Diagnostics.DebuggerTypeProxy(typeof(global::Elffy.EnumLikeMembers<>.EnumLikeMembersTypeProxy))]
#pragma warning restore CS0618
    internal sealed class EnumLikeMembers<T> : global::System.Collections.Generic.IEnumerable<T>, global::System.Collections.Generic.ICollection<T>
    {
        private readonly T[] _array;
        private static readonly global::Elffy.EnumLikeMembers<T> _empty = new global::Elffy.EnumLikeMembers<T>(global::System.Array.Empty<T>());

        public static global::Elffy.EnumLikeMembers<T> Empty => _empty;

        public int Length => _array.Length;

        int global::System.Collections.Generic.ICollection<T>.Count => Length;

        bool global::System.Collections.Generic.ICollection<T>.IsReadOnly => true;

        public ref readonly T this[int index] => ref this[index];

        private EnumLikeMembers(T[] array)
        {
            _array = array;
        }

        [global::System.Obsolete(""Don't use the method from user code."")]
        public static global::Elffy.EnumLikeMembers<T> Create(T[] array) => new global::Elffy.EnumLikeMembers<T>(array);

        public global::System.ReadOnlySpan<T> AsSpan() => (global::System.ReadOnlySpan<T>)_array;

        public T[] ToArray() => ((global::System.ReadOnlySpan<T>)_array).ToArray();

        public global::Elffy.EnumLikeMembers<T>.Enumerator GetEnumerator() => new global::Elffy.EnumLikeMembers<T>.Enumerator(_array);

        global::System.Collections.Generic.IEnumerator<T> global::System.Collections.Generic.IEnumerable<T>.GetEnumerator() => ((global::System.Collections.Generic.IEnumerable<T>)_array).GetEnumerator();

        global::System.Collections.IEnumerator global::System.Collections.IEnumerable.GetEnumerator() => _array.GetEnumerator();

        void global::System.Collections.Generic.ICollection<T>.Add(T item) => throw new global::System.NotSupportedException();
        void global::System.Collections.Generic.ICollection<T>.Clear() => throw new global::System.NotSupportedException();
        bool global::System.Collections.Generic.ICollection<T>.Contains(T item) => ((global::System.Collections.Generic.ICollection<T>)_array).Contains(item);
        void global::System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex) => _array.CopyTo(array, arrayIndex);
        bool global::System.Collections.Generic.ICollection<T>.Remove(T item) => throw new global::System.NotSupportedException();

        public struct Enumerator : global::System.Collections.Generic.IEnumerator<T>
        {
            private readonly T[] _array;
            private T _current;
            private int _index;

            public T Current => _current;

            object? global::System.Collections.IEnumerator.Current => Current;

            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            public Enumerator(T[] array)
            {
                _array = array;
                _index = 0;
                _current = default!;
            }

            public void Dispose() { }

            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            public bool MoveNext()
            {
                if(_index >= _array.Length) {
                    return false;
                }
                _current = _array[_index++];
                return true;
            }

            public void Reset()
            {
                _index = 0;
                _current = default!;
            }
        }

        [global::System.Obsolete(""Don't use the method from user code."")]
        internal sealed class EnumLikeMembersTypeProxy
        {
            [global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)]
            private readonly global::Elffy.EnumLikeMembers<T> _array;

            [global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.RootHidden)]
            public T[] Items => _array.ToArray();

            public EnumLikeMembersTypeProxy(global::Elffy.EnumLikeMembers<T> array) => _array = array;
        }
    }
}
";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static context =>
        {
            context.CancellationToken.ThrowIfCancellationRequested();
            context.AddSource("EnumLikeMembers.g.cs", SourceText.From(SourceEnumLikeMembers, Encoding.UTF8));
            context.AddSource("GenerateEnumLikeStructAttribute.g.cs", SourceText.From(SourceGenerateEnumLikeStructAttribute, Encoding.UTF8));
            context.AddSource("EnumLikeValueAttribute.g.cs", SourceText.From(SourceEnumLikeValueAttribute, Encoding.UTF8));
        });

        var generateEnumLikeStructAttr = context.CompilationProvider.Select(static (compilation, ct) =>
        {
            ct.ThrowIfCancellationRequested();
            return compilation.GetTypeByMetadataName("Elffy.GenerateEnumLikeStructAttribute") ?? throw new Exception("GenerateEnumLikeStructAttribute is not found.");
        }).WithComparer(SymbolEqualityComparer.Default);

        var enumLikeValueAttr = context.CompilationProvider.Select(static (compilation, ct) =>
        {
            ct.ThrowIfCancellationRequested();
            return compilation.GetTypeByMetadataName("Elffy.EnumLikeValueAttribute") ?? throw new Exception("EnumLikeValueAttribute is not found.");
        }).WithComparer(SymbolEqualityComparer.Default);

        var enumlikes = GetEnumLikesProvider(context.SyntaxProvider, generateEnumLikeStructAttr, enumLikeValueAttr);

        context.RegisterSourceOutput(enumlikes, static (context, enumlike) =>
        {
            context.CancellationToken.ThrowIfCancellationRequested();
            var sourceText = SourceText.From(DumpSource(enumlike), Encoding.UTF8);
            context.AddSource(enumlike.Name + ".g.cs", sourceText);
        });
    }

    private static IncrementalValuesProvider<EnumLikeData> GetEnumLikesProvider(
        SyntaxValueProvider syntaxProvider,
        IncrementalValueProvider<INamedTypeSymbol> generateEnumLikeStructAttr,
        IncrementalValueProvider<INamedTypeSymbol> enumLikeValueAttr
        )
    {
        var enumlikes = syntaxProvider
            .CreateSyntaxProvider(
            static (node, ct) =>
            {
                ct.ThrowIfCancellationRequested();
                return node is StructDeclarationSyntax { AttributeLists.Count: > 0 };
            },
            static (context, ct) =>
            {
                ct.ThrowIfCancellationRequested();
                var semantics = context.SemanticModel;
                var structSymbol = semantics.GetDeclaredSymbol((context.Node as StructDeclarationSyntax)!, ct);
                return (structSymbol, semantics);
            })
            .Combine(generateEnumLikeStructAttr.Combine(enumLikeValueAttr))
            .Select(static (pair, ct) =>
            {
                ct.ThrowIfCancellationRequested();
                var ((structSymbol, semantics), (generateEnumLikeStructAttr, enumLikeValueAttr)) = pair;
                if(structSymbol is null) { return default; }
                var comparer = SymbolEqualityComparer.Default;
                var attributes = structSymbol.GetAttributes();

                foreach(var attr in attributes) {
                    ct.ThrowIfCancellationRequested();
                    if(comparer.Equals(attr.AttributeClass, generateEnumLikeStructAttr) == false) { continue; }

                    var arg0 = attr.ConstructorArguments[0];
                    if(arg0.Kind != TypedConstantKind.Type) { return default; }
                    var underlyingType = arg0.Value!.ToString();
                    if(CheckUnderlyingType(underlyingType) == false) { throw new Exception("Underlying type of GenerateEnumLikeStructAttribute is invalid."); }
                    var members = GetMembers(attributes, enumLikeValueAttr);
                    return new EnumLikeData(structSymbol.ContainingNamespace.ToString(), structSymbol.Name, underlyingType, members);
                }
                return default;
            })
            .Where(static x => x is not null)!
            .WithComparer(EnumLikeData.Comparer);
        return enumlikes;
    }

    private static EnumLikeMemberData[] GetMembers(ImmutableArray<AttributeData> attributes, INamedTypeSymbol enumLikeValueAttr)
    {
        return EnumerateMembers(attributes, enumLikeValueAttr).ToArray();

        static IEnumerable<EnumLikeMemberData> EnumerateMembers(ImmutableArray<AttributeData> attributes, INamedTypeSymbol enumLikeValueAttr)
        {
            var comparer = SymbolEqualityComparer.Default;
            foreach(var attr in attributes) {
                if(comparer.Equals(attr.AttributeClass, enumLikeValueAttr) == false) { continue; }
                var args = attr.ConstructorArguments;
                var name = args[0].Value?.ToString() ?? throw new Exception();
                var value = args[1].Value?.ToString() ?? throw new Exception();
                var access = args.Length >= 3 ? args[2].Value?.ToString() : "public";
                var description = args.Length >= 4 ? args[3].Value?.ToString() : "";
                yield return new EnumLikeMemberData(name, value, access!, description!);
            }
        }
    }

    private static bool CheckUnderlyingType(string underlyingType)
    {
        return underlyingType is "int" or "uint" or "short" or "ushort" or "sbyte" or "byte" or "long" or "ulong";
    }

    private static string DumpSource(EnumLikeData data)
    {
        var sb = new StringBuilder();
        sb.Append(
$@"// <auto-generated>
// Auto generated by a source generator.
// Generator: Elffy.Generator.EnumLikeStructGenerator
// </auto-generated>

#nullable enable
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;

namespace {data.Namespace}
{{
    [global::System.Diagnostics.DebuggerDisplay(""{{ToString(),nq}}"")]
    readonly partial struct {data.Name} : global::System.IEquatable<{data.Name}>
    {{
        [global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)]
        private readonly {data.UnderlyingType} _value;

        [global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)]
        private static readonly {data.Name}[] _allValues = new {data.Name}[]
        {{
").AppendForeach(data.Members, nv =>
@$"            {nv.Name},
").Append(
$@"        }};

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static readonly {data.Name}[] _allPublicValues = new {data.Name}[]
        {{
").AppendForeach(data.Members.Where(x => x.Accessibility == "public"), nv =>
@$"            {nv.Name},
").Append(
$@"        }};

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static readonly string[] _allNames = new string[]
        {{
").AppendForeach(data.Members, nv =>
@$"            ""{nv.Name}"",
").Append(
$@"        }};

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static readonly string[] _allPublicNames = new string[]
        {{
").AppendForeach(data.Members.Where(x => x.Accessibility == "public"), nv =>
@$"            ""{nv.Name}"",
").Append(
$@"        }};

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static readonly (string Name, {data.Name} Value)[] _allNameValues = new (string Name, {data.Name} Value)[]
        {{
").AppendForeach(data.Members, nv =>
@$"            (Name: ""{nv.Name}"", Value: {nv.Name}),
").Append(
$@"        }};

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static readonly (string Name, {data.Name} Value)[] _allPublicNameValues = new (string Name, {data.Name} Value)[]
        {{
").AppendForeach(data.Members.Where(x => x.Accessibility == "public"), nv =>
@$"            (Name: ""{nv.Name}"", Value: {nv.Name}),
").Append(
$@"        }};

").AppendForeach(data.Members, nv =>
$@"        /// <summary>{nv.Description}</summary>
        {nv.Accessibility} static {data.Name} {nv.Name} => new {data.Name}(({data.UnderlyingType}){nv.Value});
").Append($@"

        private {data.Name}({data.UnderlyingType} value) => _value = value;

        internal static ReadOnlySpan<{data.Name}> AllValuesSpan() => _allValues;

        internal static IEnumerable<{data.Name}> AllValues() => _allValues;

        internal static ReadOnlySpan<string> AllNamesSpan() => _allNames;

        internal static IEnumerable<string> AllNames() => _allNames;

        internal static ReadOnlySpan<(string Name, {data.Name} Value)> AllNameValuesSpan() => _allNameValues;

        internal static IEnumerable<(string Name, {data.Name} Value)> AllNameValues() => _allNameValues;

        public static ReadOnlySpan<{data.Name}> AllPublicValuesSpan() => _allPublicValues;

        public static IEnumerable<{data.Name}> AllPublicValues() => _allPublicValues;

        public static ReadOnlySpan<string> AllPublicNamesSpan() => _allPublicNames;

        public static IEnumerable<string> AllPublicNames() => _allPublicNames;

        public static ReadOnlySpan<(string Name, {data.Name} Value)> AllPublicNameValuesSpan() => _allPublicNameValues;

        public static IEnumerable<(string Name, {data.Name} Value)> AllPublicNameValues() => _allPublicNameValues;

        public override bool Equals(object? obj) => obj is {data.Name} v && Equals(v);

        public bool Equals({data.Name} other) => _value == other._value;

        public override int GetHashCode() => _value.GetHashCode();

        public static bool operator ==({data.Name} left, {data.Name} right) => left.Equals(right);

        public static bool operator !=({data.Name} left, {data.Name} right) => !(left == right);
");
        AppendToStringSource(sb, data.Members, data.UnderlyingType);
        sb.Append(@"
    }
}
");
        return sb.ToString();
    }

    private static void AppendToStringSource(StringBuilder sb, EnumLikeMemberData[] members, string underlyingType)
    {
        var sorted = (underlyingType == "ulong")
            ? members.OrderBy(x => ulong.Parse(x.Value)).Select(x => (x.Name, x.Value)).ToArray()
            : members.OrderBy(x => long.Parse(x.Value)).Select(x => (x.Name, x.Value)).ToArray();
        sb.AppendLine(@"
        public override string ToString()
        {
            var value = _value;");
        Foo(sorted, 3, sb);
        sb.AppendLine(@"
        }");

        static void Foo(ReadOnlySpan<(string Name, string Value)> span, int depth, StringBuilder sb)
        {
            var indent = new string(' ', depth * 4);
            if(span.Length == 0) {
                sb.AppendLine($"{indent}return \"\";");
                return;
            }
            if(span.Length == 1) {
                sb.AppendLine($"{indent}return (value == {span[0].Value}) ? \"{span[0].Name}\" : \"\";");
                return;
            }
            var m = span.Length / 2;
            var mid = span[m - 1].Value;
            sb.AppendLine(@$"{indent}if(value <= {mid}) {{");
            Foo(span.Slice(0, m), depth + 1, sb);
            sb.AppendLine($"{indent}}} else {{");
            Foo(span.Slice(m), depth + 1, sb);
            sb.AppendLine($"{indent}}}");
        }
    }

    private sealed class EnumLikeData : IEquatable<EnumLikeData?>
    {
        public static readonly EnumLikeDataEqualityComparer Comparer = new EnumLikeDataEqualityComparer();

        public string Namespace { get; }
        public string Name { get; }
        public string UnderlyingType { get; }
        public EnumLikeMemberData[] Members { get; }

        public EnumLikeData(string ns, string name, string underlyingType, EnumLikeMemberData[]? members)
        {
            Namespace = ns;
            Name = name;
            UnderlyingType = underlyingType;
            Members = members ?? Array.Empty<EnumLikeMemberData>();
        }

        public override bool Equals(object? obj) => Equals(obj as EnumLikeData);

        public bool Equals(EnumLikeData? other)
        {
            if(other == null) { return false; }
            var a = Namespace == other.Namespace &&
                    Name == other.Name &&
                    UnderlyingType == other.UnderlyingType;
            if(a == false) { return false; }
            var comparer = EnumLikeMemberData.Comparer;
            var members = Members;
            var otherMembers = other.Members;
            if(members.Length != otherMembers.Length) { return false; }
            for(int i = 0; i < members.Length; i++) {
                if(comparer.Equals(members[i], otherMembers[i]) == false) {
                    return false;
                }
            }
            return true;
        }

        public override int GetHashCode()
        {
            int hashCode = -625865624;
            hashCode = hashCode * -1521134295 + EqualityComparer<string>.Default.GetHashCode(Namespace);
            hashCode = hashCode * -1521134295 + EqualityComparer<string>.Default.GetHashCode(Name);
            hashCode = hashCode * -1521134295 + EqualityComparer<string>.Default.GetHashCode(UnderlyingType);
            hashCode = hashCode * -1521134295 + EqualityComparer<EnumLikeMemberData[]>.Default.GetHashCode(Members);
            return hashCode;
        }

        public sealed class EnumLikeDataEqualityComparer : IEqualityComparer<EnumLikeData>
        {
            public bool Equals(EnumLikeData x, EnumLikeData y)
            {
                if(x == null) {
                    if(y == null) { return true; }
                    return false;
                }
                if(y == null) { return false; }
                return x.Equals(y);
            }

            public int GetHashCode(EnumLikeData obj) => obj?.GetHashCode() ?? 0;
        }
    }

    private sealed class EnumLikeMemberData : IEquatable<EnumLikeMemberData?>
    {
        public static readonly EnumLikeMemberDataEqualityComparer Comparer = new EnumLikeMemberDataEqualityComparer();

        public string Name { get; }
        public string Value { get; }
        public string Accessibility { get; }
        public string Description { get; }

        public EnumLikeMemberData(string name, string value, string accessibility, string description)
        {
            Name = name;
            Value = value;
            Accessibility = accessibility;
            Description = description;
        }

        public override bool Equals(object? obj) => Equals(obj as EnumLikeMemberData);

        public bool Equals(EnumLikeMemberData? other)
        {
            return other != null && Name == other.Name && Value == other.Value &&
                   Accessibility == other.Accessibility && Description == other.Description;
        }

        public override int GetHashCode()
        {
            int hashCode = 1887696864;
            hashCode = hashCode * -1521134295 + EqualityComparer<string>.Default.GetHashCode(Name);
            hashCode = hashCode * -1521134295 + EqualityComparer<string>.Default.GetHashCode(Value);
            hashCode = hashCode * -1521134295 + EqualityComparer<string>.Default.GetHashCode(Accessibility);
            hashCode = hashCode * -1521134295 + EqualityComparer<string>.Default.GetHashCode(Description);
            return hashCode;
        }

        public sealed class EnumLikeMemberDataEqualityComparer : IEqualityComparer<EnumLikeMemberData>
        {
            public bool Equals(EnumLikeMemberData x, EnumLikeMemberData y)
            {
                if(x == null) {
                    if(y == null) { return true; }
                    return false;
                }
                if(y == null) { return false; }
                return x.Equals(y);
            }

            public int GetHashCode(EnumLikeMemberData obj) => obj?.GetHashCode() ?? 0;
        }
    }
}

internal static class StringBuilderExtension
{
    public static StringBuilder AppendForeach<T>(this StringBuilder sb, IEnumerable<T> items, Func<T, string> func)
    {
        foreach(var item in items) {
            sb.Append(func(item));
        }
        return sb;
    }

    //public static StringBuilder AppendForeach<T>(this StringBuilder sb, ReadOnlySpan<T> span, Func<T, string> func, string separator)
    //{
    //    //using var e = span.GetEnumerator();
    //    var e = span.GetEnumerator();
    //    if(e.MoveNext() == false) { return sb; }
    //    while(true) {
    //        sb.Append(func(e.Current));
    //        if(e.MoveNext() == false) { break; }
    //        sb.Append(separator);
    //    }
    //    return sb;
    //}
}
