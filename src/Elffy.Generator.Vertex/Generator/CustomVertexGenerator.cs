#nullable enable
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Linq;
using System.Text;
using System.Globalization;
using System.Collections.Generic;
using System;
using System.Collections.Immutable;
using System.Threading;

namespace Elffy.Generator;

[Generator]
public class CustomVertexGenerator : IIncrementalGenerator
{
    private const string GenerateVertexAttributeSource =
@"// <auto-generated>
// Auto generated by a source generator.
// Generator: Elffy.Generator.CustomVertexGenerator
// </auto-generated>

#nullable enable

namespace Elffy
{
    [global::System.Diagnostics.Conditional(""COMPILE_TIME_ONLY"")]
    [global::System.AttributeUsage(global::System.AttributeTargets.Struct, AllowMultiple = false, Inherited = false)]
    internal sealed class GenerateVertexAttribute : global::System.Attribute
    {
        public GenerateVertexAttribute()
        {
        }
    }
}
";
    private const string VertexFieldAttributeSource =
@"// <auto-generated>
// Auto generated by a source generator.
// Generator: Elffy.Generator.CustomVertexGenerator
// </auto-generated>

#nullable enable

namespace Elffy
{
    [global::System.Diagnostics.Conditional(""COMPILE_TIME_ONLY"")]
    [global::System.AttributeUsage(global::System.AttributeTargets.Struct, AllowMultiple = true, Inherited = false)]
    internal sealed class VertexFieldAttribute : global::System.Attribute
    {
        public VertexFieldAttribute(
            string name,
            global::System.Type type,
            global::Elffy.VertexFieldSemantics fieldSemantics,
            uint byteOffset,
            global::Elffy.VertexFieldMarshalType marshalType,
            uint marshalCount)
        {
        }
    }
}
";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static context =>
        {
            context.CancellationToken.ThrowIfCancellationRequested();
            context.AddSource("GenerateVertexAttribute.g.cs", SourceText.From(GenerateVertexAttributeSource, Encoding.UTF8));
            context.AddSource("VertexFieldAttribute.g.cs", SourceText.From(VertexFieldAttributeSource, Encoding.UTF8));
        });

        var generateVertexAttrClass = context.CompilationProvider
            .Select(static (compilation, ct) =>
            {
                ct.ThrowIfCancellationRequested();
                return compilation.GetTypeByMetadataName("Elffy.GenerateVertexAttribute") ?? throw new Exception("GenerateVertexAttribute is not found.");
            })
            .WithComparer(SymbolEqualityComparer.Default);

        var vertexFieldAttrClass = context.CompilationProvider
            .Select(static (compilation, ct) =>
            {
                ct.ThrowIfCancellationRequested();
                return compilation.GetTypeByMetadataName("Elffy.VertexFieldAttribute") ?? throw new Exception("VertexFieldAttribute is not found.");
            })
            .WithComparer(SymbolEqualityComparer.Default);

        var vertexDefinitions = context.SyntaxProvider.CreateSyntaxProvider(
            static (node, ct) =>
            {
                ct.ThrowIfCancellationRequested();
                return node is StructDeclarationSyntax { AttributeLists.Count: > 0 };
            },
            static (context, ct) =>
            {
                ct.ThrowIfCancellationRequested();
                var semantics = context.SemanticModel;
                var structSymbol = semantics.GetDeclaredSymbol((context.Node as StructDeclarationSyntax)!, ct);
                return structSymbol;
            })
            .Combine(generateVertexAttrClass.Combine(vertexFieldAttrClass))
            .Select(static (x, ct) =>
            {
                ct.ThrowIfCancellationRequested();
                var (structSymbol, (generateVertexAttr, vertexFieldAttr)) = x;
                if(structSymbol is null) { return default; }
                var comparer = SymbolEqualityComparer.Default;

                var attributes = structSymbol.GetAttributes();
                var isVertex = FindOrDefault(attributes, generateVertexAttr, SymbolEqualityComparer.Default, ct) is not null;
                if(isVertex == false) {
                    return default;
                }
                var structNS = structSymbol.ContainingNamespace.ToString();
                var structName = structSymbol.Name;

                var fields = new List<VertexFieldInfo>();
                foreach(var attrData in attributes) {
                    if(comparer.Equals(attrData.AttributeClass, vertexFieldAttr) == false) { continue; }
                    var name = GetConstructorArgString(attrData, 0) ?? throw new Exception();
                    var type = GetConstructorArgType(attrData, 1) ?? throw new Exception();
                    var semantics = GetAttrArgEnum<VertexFieldSemantics>(attrData, 2) ?? throw new Exception();
                    var byteOffset = GetConstructorArgUInt(attrData, 3) ?? throw new Exception();
                    var marshalType = GetAttrArgEnum<VertexFieldMarshalType>(attrData, 4) ?? throw new Exception();
                    var marshalCount = GetConstructorArgUInt(attrData, 5) ?? throw new Exception();
                    var field = new VertexFieldInfo(name, type, semantics, byteOffset, marshalType, marshalCount);
                    fields.Add(field);
                }
                return new VertexInfo(structNS, structName, fields);
            })
            .Where(static x => x != null);

        context.RegisterSourceOutput(vertexDefinitions, static (context, vertex) =>
        {
            context.CancellationToken.ThrowIfCancellationRequested();
            var source = CreateSource(vertex!.Namespace, vertex.Name, vertex.Fields.ToArray());   // TODO:
            context.AddSource(vertex.Name + ".g.cs", SourceText.From(source, Encoding.UTF8));
        });
    }

    private sealed class VertexInfo
    {
        public string Namespace { get; }
        public string Name { get; }

        public List<VertexFieldInfo> Fields { get; }

        public VertexInfo(string ns, string name, List<VertexFieldInfo> fields)
        {
            Namespace = ns;
            Name = name;
            Fields = fields;
        }
    }

    private static AttributeData? FindOrDefault(ImmutableArray<AttributeData> attributes, INamedTypeSymbol target, SymbolEqualityComparer comparer, CancellationToken ct)
    {
        foreach(var attr in attributes) {
            ct.ThrowIfCancellationRequested();
            if(comparer.Equals(attr.AttributeClass, target)) {
                return attr;
            }
        }
        return null;
    }

    private static T? GetAttrArgEnum<T>(AttributeData attrData, int argIndex) where T : struct, Enum
    {
        var str = attrData.ConstructorArguments[argIndex].Value?.ToString();
        return (str != null) ? Enum.TryParse<T>(str, out var value) ? value : null : null;
    }

    private static string? GetConstructorArgString(AttributeData attrData, int argIndex)
    {
        return attrData.ConstructorArguments[argIndex].Value?.ToString();
    }

    private static uint? GetConstructorArgUInt(AttributeData attrData, int argIndex)
    {
        var value = attrData.ConstructorArguments[argIndex].Value?.ToString();
        return (value != null) ? uint.TryParse(value, out var num) ? num : null : null;
    }

    private static string? GetConstructorArgType(AttributeData attrData, int argIndex)
    {
        var arg = attrData.ConstructorArguments[argIndex];
        if(arg.Kind != TypedConstantKind.Type) { return null; }
        var type = arg.Value?.ToString();
        return type switch
        {
            "byte" => "System.Byte",
            "sbyte" => "System.SByte",
            "short" => "System.Int16",
            "ushort" => "System.UInt16",
            "int" => "System.Int32",
            "uint" => "System.UInt32",
            "long" => "System.Int64",
            "ulong" => "System.UInt64",
            "float" => "System.Single",
            "double" => "System.Double",
            "decimal" => "System.Decimal",
            _ => type,
        };
    }

    private static string CreateSource(string vertexNamespace, string vertexName, VertexFieldInfo[] fields)
    {
        var sb = new StringBuilder();
        sb.Append($$"""
// <auto-generated>
// Auto generated by a source generator.
// Generator: Elffy.Generator.CustomVertexGenerator
// </auto-generated>

#nullable enable

namespace {{vertexNamespace}}
{
    [global::System.Runtime.InteropServices.StructLayout(global::System.Runtime.InteropServices.LayoutKind.Explicit)]
    [global::Elffy.Vertex]
    partial struct {{vertexName}} : global::System.IEquatable<{{vertexName}}>, global::Elffy.IVertex
    {

""");
        sb.AppendForeach(fields, f => $$"""
        [global::System.Runtime.InteropServices.FieldOffset({{f.ByteOffset}})]
        public global::{{f.TypeFullName}} {{f.Name}};


""");
        sb.Append($$"""
        private static global::Elffy.VertexTypeData _vertexTypeData = default!;

        [global::System.Runtime.CompilerServices.ModuleInitializer]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        [global::System.Obsolete("Don't call the method explicitly.", true)]
        internal static void RegisterVertexTypeDataOnModuleInitialized()
        {
            _vertexTypeData = global::Elffy.VertexTypeData.Register<{{vertexName}}>(

""").AppendForeach(fields, f => $$"""
                new global::Elffy.VertexFieldData(nameof({{f.Name}}), typeof({{f.TypeFullName}}), {{nameof(VertexFieldSemantics)}}.{{f.Semantics}}, {{f.ByteOffset}}, {{nameof(VertexFieldMarshalType)}}.{{f.Marshal}}, {{f.MarshalCount}})
""", @",
").Append($$"""
);
        }

        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public {{vertexName}}(
""").AppendForeach(fields, f => $"in {f.TypeFullName} {f.NameLowerCamelCase}", ", ").Append(@")
        {").AppendForeach(fields, f => @$"
            {f.Name} = {f.NameLowerCamelCase};").Append($$"""

        }

        public readonly override bool Equals(object? obj) => obj is {{vertexName}} vertex && Equals(vertex);

        public readonly bool Equals({{vertexName}} other) => 
""").AppendForeach(fields, f => $"{f.Name}.Equals(other.{f.Name})", " && ").Append(@";

        public readonly override int GetHashCode() => global::System.HashCode.Combine(").AppendForeach(fields, f => f.Name, ", ").Append(@");
").Append($$"""

        public static bool operator ==(in {{vertexName}} left, in {{vertexName}} right) => left.Equals(right);

        public static bool operator !=(in {{vertexName}} left, in {{vertexName}} right) => !(left == right);


""").Append($$"""
        /// <inheritdoc/>
        public static global::Elffy.VertexTypeData VertexTypeData => _vertexTypeData;

        /// <inheritdoc/>
        public static int FieldCount => {{fields.Length}};
        
        /// <inheritdoc/>
        public static int VertexSize => global::System.Runtime.CompilerServices.Unsafe.SizeOf<{{vertexName}}>();

        /// <inheritdoc/>
        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static bool HasField(VertexFieldSemantics semantics) => _vertexTypeData.HasField(semantics);

        /// <inheritdoc/>
        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static global::Elffy.VertexFieldAccessor<TField> GetAccessor<TField>(VertexFieldSemantics semantics) where TField : unmanaged => TryGetAccessor<TField>(semantics, out var accessor) ? accessor : throw new global::System.InvalidOperationException("Cannot get the field accessor.");

        /// <inheritdoc/>
        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static global::Elffy.VertexFieldAccessor<global::Elffy.Vector3> GetNormalAccessor() => TryGetNormalAccessor(out var accessor) ? accessor : throw new global::System.InvalidOperationException("Cannot get the field accessor.");

        /// <inheritdoc/>
        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static global::Elffy.VertexFieldAccessor<global::Elffy.Vector3> GetPositionAccessor() => TryGetPositionAccessor(out var accessor) ? accessor : throw new global::System.InvalidOperationException("Cannot get the field accessor.");

        /// <inheritdoc/>
        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static global::Elffy.VertexFieldAccessor<global::Elffy.Vector2> GetUVAccessor() => TryGetUVAccessor(out var accessor) ? accessor : throw new global::System.InvalidOperationException("Cannot get the field accessor.");

        /// <inheritdoc/>
        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static bool TryGetAccessor<TField>(global::Elffy.VertexFieldSemantics semantics, out global::Elffy.VertexFieldAccessor<TField> accessor) where TField : unmanaged => _vertexTypeData.TryGetFieldAccessor(semantics, out accessor);

        /// <inheritdoc/>
        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static bool TryGetNormalAccessor(out global::Elffy.VertexFieldAccessor<global::Elffy.Vector3> accessor) => TryGetAccessor(global::Elffy.VertexFieldSemantics.Normal, out accessor);

        /// <inheritdoc/>
        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static bool TryGetPositionAccessor(out global::Elffy.VertexFieldAccessor<global::Elffy.Vector3> accessor) => TryGetAccessor(global::Elffy.VertexFieldSemantics.Position, out accessor);

        /// <inheritdoc/>
        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        public static bool TryGetUVAccessor(out global::Elffy.VertexFieldAccessor<global::Elffy.Vector2> accessor) => TryGetAccessor(global::Elffy.VertexFieldSemantics.UV, out accessor);
    }
}
""");
        return sb.ToString();
    }

    private class VertexFieldInfo
    {
        public string Name { get; }
        public string TypeFullName { get; }
        public VertexFieldSemantics Semantics { get; }
        public uint ByteOffset { get; }
        public VertexFieldMarshalType Marshal { get; }
        public uint MarshalCount { get; }

        public string NameLowerCamelCase
        {
            get
            {
                if(string.IsNullOrEmpty(Name)) {
                    return Name;
                }
                var t = CultureInfo.CurrentCulture.TextInfo;
                if(Name.All(c => char.IsUpper(c))) {
                    return Name.ToLower();
                }
                return t.ToLower(Name[0]) + Name.Substring(1);
            }
        }

        public VertexFieldInfo(string name, string typeFullName, VertexFieldSemantics semantics, uint byteOffset, VertexFieldMarshalType marshal, uint marshalCount)
        {
            Name = name;
            TypeFullName = typeFullName;
            Semantics = semantics;
            ByteOffset = byteOffset;
            Marshal = marshal;
            MarshalCount = marshalCount;
        }
    }
}

internal static class StringBuilderExtensions
{
    public static StringBuilder AppendForeach<T>(this StringBuilder sb, T[] array, Func<T, string> func)
    {
        foreach(var item in array) {
            sb.Append(func(item));
        }
        return sb;
    }

    public static StringBuilder AppendForeach<T>(this StringBuilder sb, IEnumerable<T> list, Func<T, string> func, string separator)
    {
        using var e = list.GetEnumerator();
        if(e.MoveNext() == false) { return sb; }
        while(true) {
            sb.Append(func(e.Current));
            if(e.MoveNext() == false) { break; }
            sb.Append(separator);
        }
        return sb;
    }
}
